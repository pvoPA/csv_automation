"""
Exports vulnerability data to CSV on host resources in Prisma Cloud.

This script is used to retrieve vulnerability data for host resources
and exports it to a CSV file with the following actions,
    - Generate Prisma Token
    - Delete the CSV file if it exists from a previous run
    - Grab host scan results
    - For each API call,
        - Flatten vulnerability list for each host
        - Write to CSV (Create a CSV directory and file.)

Usage:
    python export_host_vulnerability_csv.py

Options:

Requirements:
    - Python 3.10 or higher
    - .env configured with the following variables,
        - PRISMA_ACCESS_KEY
        - PRISMA_SECRET_KEY

Example:
    python export_host_vulnerability_csv.py

Note:
    This script is meant to be deployed in a docker container or azure function.
"""
import os
import json
import datetime as dt
from helpers import logger
from helpers import generate_prisma_token
from helpers import write_data_to_csv
from helpers import prisma_get_host_scan_results


def etl_host_vulnerabilities_csv():
    """
    Gets host vulnerability data from Prisma and cleans up for exporting to CSV.

    Parameters:
        None

    Returns:
        None

    """
    todays_date = str(dt.datetime.today()).split()[0]
    COLLECTIONS_FILTER = ", ".join(json.loads(os.getenv("HOST_COLLECTIONS_FILTER")))
    host_vulnerability_csv_name = os.getenv("HOST_VULNERABILITY_CSV_NAME")
    host_vulnerability_fields_of_interest = json.loads(
        os.getenv("HOST_VULNERABILITY_FIELDS_OF_INTEREST")
    )
    file_path = f"CSVs/{host_vulnerability_csv_name}_{todays_date}.csv"
    prisma_access_key = os.getenv("PRISMA_ACCESS_KEY")
    prisma_secret_key = os.getenv("PRISMA_SECRET_KEY")
    host_vulnerability_fields = [
        "Incremental_ID",
        "Resource_ID",
        "Package_Path",
        "severity",
        "published",
        "vecStr",
        "exploit",
        "cri",
        "text",
        "type",
        "fixDate",
        "discovered",
        "title",
        "functionLayer",
        "cve",
        "twistlock",
        "riskFactors",
        "layerTime",
        "description",
        "link",
        "cause",
        "status",
        "templates",
        "applicableRules",
        "cvss",
        "id",
        "packageName",
        "packageVersion",
        "binaryPkgs",
        "exploits",
        "fixLink",
        "vulnTagInfos",
    ]

    ###########################################################################
    # Generate Prisma Token

    prisma_token = generate_prisma_token(prisma_access_key, prisma_secret_key)

    ###########################################################################
    # Delete the CSV file if it exists from a previous run

    try:
        os.remove(file_path)
    except FileNotFoundError:
        pass

    ###########################################################################
    # Get hosts from Prisma

    end_of_page = False
    new_file = True
    offset = 0
    incremental_id = 0
    page_limit = 50

    while not end_of_page:
        vulnerability_list = list()

        host_response, status_code = prisma_get_host_scan_results(
            prisma_token, offset=offset, limit=page_limit, collection=COLLECTIONS_FILTER
        )

        if status_code == 200:
            if host_response:
                ###############################################################
                # Flatten vulnerability list for each host
                for host in host_response:
                    if "vulnerabilities" in host:
                        if host["vulnerabilities"]:
                            for vuln in host["vulnerabilities"]:
                                # Add the individual vulnerability information
                                vulnerability_dict = {
                                    key: value
                                    for key, value in vuln.items()
                                    # if (key in host_vulnerability_fields_of_interest)
                                }

                                vulnerability_dict.update({"Resource_ID": host["_id"]})

                                # Get the package info and install path
                                PACKAGE_NAME = vuln["packageName"]
                                PACKAGE_VERSION = vuln["packageVersion"]
                                PACKAGE_PATH = "NOT_AVAILABLE"

                                package_found = False

                                if PACKAGE_NAME:
                                    for package_type in host["packages"]:
                                        for package in package_type["pkgs"]:
                                            if (
                                                package["name"] == PACKAGE_NAME
                                                and package["version"]
                                                == PACKAGE_VERSION
                                            ):
                                                if "path" in package:
                                                    PACKAGE_PATH = package["path"]
                                                package_found = True
                                                break

                                    # Check "applications" field for package path
                                    if not package_found:
                                        if "applications" in host:
                                            for app in host["applications"]:
                                                if (
                                                    app["name"] == PACKAGE_NAME
                                                    and app["version"]
                                                    == PACKAGE_VERSION
                                                ):
                                                    PACKAGE_PATH = app["path"]
                                                    package_found = True
                                                    break

                                    # Check "binaries" field for package path
                                    if not package_found:
                                        if "binaries" in host:
                                            for binary in host["binaries"]:
                                                if binary["name"] == PACKAGE_NAME:
                                                    PACKAGE_PATH = binary["path"]
                                                    package_found = True
                                                    break

                                    # Check "startupBinaries" field for package path
                                    if not package_found:
                                        if "binaries" in host:
                                            for binary in host["binaries"]:
                                                if binary["name"] == PACKAGE_NAME:
                                                    PACKAGE_PATH = binary["path"]
                                                    package_found = True
                                                    break

                                if package_found:
                                    vulnerability_dict["Package_Path"] = PACKAGE_PATH

                                vulnerability_dict.update(
                                    {"Incremental_ID": incremental_id}
                                )

                                vulnerability_list.append(vulnerability_dict)

                                incremental_id += 1

                ##############################################################
                # Write to CSV
                write_data_to_csv(
                    file_path, vulnerability_list, host_vulnerability_fields, new_file
                )
                new_file = False

                offset += page_limit
            else:
                end_of_page = True
                break
        elif status_code == 401:
            logger.error("Prisma token timed out, generating a new one and continuing.")

            prisma_token = generate_prisma_token(prisma_access_key, prisma_secret_key)
        else:
            logger.error("API returned %s.", status_code)


if __name__ == "__main__":
    logger.info("Creating host vulnerabilities CSV...")

    etl_host_vulnerabilities_csv()
